<!DOCTYPE html>
<meta charset="utf-8">
<body>
<script src="https://d3js.org/d3.v6.min.js"></script>
<script src="../dist/@observablehq/plot.umd.js"></script>
<script>

d3.csv("data/alphabet.csv", d3.autoType).then(alphabet => {
  document.body.appendChild(Plot.plot(alphabet, {
    scales: {
      y: {
        invert: true // TODO implicitly invert when band or point in y
      }
    },
    axes: {
      x: {label: "Frequency (%) →", grid: true},
      y: {label: null}
    },
    marks: [
      new Plot.RuleX([0]),
      new Plot.Bar({x: d => d.frequency * 100, y: "letter"})
    ]
  }));
});

false && d3.csv("data/nc-absentee-votes.csv", d3.autoType).then(votes => {
  const races = ["BLACK or AFRICAN AMERICAN", "WHITE"];
  const statusAccepted = ["ACCEPTED", "ACCEPTED - CURED"];
  const statusPending = ["PENDING", "PENDING CURE"];

  // Filter for mail ballots.
  // Filter for specific races.
  // Group by race, then by accepted/pending/rejected status.
  // Compute the count for each race & status.
  // Compute the count for each race.
  // Compute the normalized rate for each status within each race.
  const rollup = d3.rollups(
    votes
      .filter(d => d.ballot_req_type === "MAIL")
      .filter(d => races.includes(d.race)),
    votes => d3.sum(votes, d => d.count),
    d => d.race,
    d => statusAccepted.includes(d.ballot_rtn_status) ? "ACCEPTED"
      : statusPending.includes(d.ballot_rtn_status) ? "PENDING"
      : "REJECTED"
  ).flatMap(([race, group]) => {
    const total = d3.sum(group, ([, count]) => count);
    return group.map(([status, count]) => {
      return {race, status, percent: count / total * 100};
    });
  });

  document.body.appendChild(Plot.Bar(rollup, {
    x: {value: "percent", grid: true, axis: "top", label: "Frequency (%) →"},
    fy: {value: "race", label: null},
    y: {value: "status", label: null},
    marginLeft: 160
  }));
});

</script>
